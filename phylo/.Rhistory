results.start <- which(data.in == "Results")
data.out <- data.in[1:(results.start - 2),]
data.out
read.synergy <- function(input = " ", skip = ""){
data.in <- read.delim(input, skip=skip, header=T, as.is=T)
results.start <- which(data.in == "Results")
data.out <- data.in[1:(results.start - 2),]
colnames(data.out)[2] <- "Temp"
data.out$Time <- as.character(data.out$Time)
t.h <- as.numeric(lapply(strsplit(data.out$Time, "\\:"), "[", 1))
t.m <- as.numeric(lapply(strsplit(data.out$Time, "\\:"), "[", 2))
data.out$Time <- round(t.h + t.m/60, 2)
for (i in 1:dim(data.out)[2]){
if (is.numeric(data.out[,i]) == FALSE){data.out[,i] = as.numeric(data.out[,i])}}
return(data.out)
}
file <- '/Users/WRShoemaker/GitHub/PopGen/Growth_curve/data/raw/GrowthCurve_Example.txt'
file
data.in <- read.synergy(input, skip = 31)
data.in <- read.synergy(fie, skip = 31)
data.in <- read.synergy(file, skip = 31)
data.in
t.trim <- c(1, 1.2, 1.4, 1.5, 1.8, 1.9, 3.0, 3.5, 3.8, 4.0, 4.2, 4.4, 4.6, 4.8)
m.gomp<-function(t,pars){
b0<-pars[1]
A<-pars[2]
umax<-pars[3]
L<-pars[4]
b0+A*exp(-exp(umax*exp(1)*(L-t)/A+1))
}
s.trim <- c(0.01, 0.01, 0.016, 0.02, 0.03, 0.04,0.06, 0.08, 0.09, 0.10, 0.12, 0.14, 0.16, 0.18)
b0 <- 0.1
A <- 0.15
umax <- 0.5
L <- 3
s.trim~dnorm(mean=m.gomp(t.trim,c(b0,A,umax,L)),
sd=exp(z))
dnorm(mean=m.gomp(t.trim,c(b0,A,umax,L)),
sd=exp(z))
dnorm(mean=m.gomp(t.trim,c(b0,A,umax,L)),
sd=exp(z)
dnorm(mean=m.gomp(t.trim,c(b0,A,umax,L)), sd=exp(z))
dnorm(s.trim, mean=m.gomp(t.trim,c(b0,A,umax,L)), sd=exp(z))
dnorm(s.trim, mean=m.gomp(t.trim,c(b0,A,umax,L)), sd=exp(-0.5))
m.gomp(t.trim,c(b0,A,umax,L)
m.gomp(t.trim,c(b0,A,umax,L))
m.gomp(t.trim,c(b0,A,umax,L))
dnorm(s.trim, mean=m.gomp(t.trim,c(b0,A,umax,L)), sd=exp(-0.5))
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/")
library('bbmle')
## Load Data
obs <- read.csv("data/longtermdormancy_20170620_nocomments.csv",
header = TRUE, stringsAsFactors = FALSE)
## Adding 1 to deal with log(0) observations
obs$Abund <- as.numeric(obs$Colonies) * 10 ^ as.numeric(obs$Dilution) + 1
strains <- sort(unique(obs$Strain))
strains <- strains[table(obs$Strain)>10]
obs <- obs[obs$Strain%in%strains,]
summ <- matrix(NA,length(strains)*max(obs$Rep),8)
pdf('output/decayFitsWeibull.pdf') # Uncomment to create pdf that will plot data and fits
counter <- 1
for(i in 1:length(strains)){
strainObs=obs[obs$Strain==strains[i],]
reps=unique(strainObs$Rep)
for(j in 1:length(reps)){
repObs=strainObs[strainObs$Rep==reps[j],]
# minimum of 10 data points
if(nrow(repObs)>10){
start=repObs[1,1]
time=(as.numeric(strptime(repObs$Firstread_date,format="%d-%b-%y",tz="EST"))-
as.numeric(strptime(start,format="%d-%b-%y",tz="EST")))/(3600*24)
repObs["time"] <- time + 1
repObs["logabund"] <- log10(repObs$Abund)
if (repObs["logabund"][[1]][2] - repObs["logabund"][[1]][1] > 1){
repObs <- repObs[-c(1), ]
}
repObs["prop"] <- repObs$logabund / repObs$logabund[1]
#KBS0703.1$prop <- KBS0703.1$logabund/KBS0703.1$logabund[1]
# Initial parameters
#A = 200 # Initial death (larger = slower)
#B = 1 # Bend (upper = 1 = first-order decay)
#C = round(max(repObs$logabund),1) # intercept
#Z = 6 # Error
grids<-list(a=c(1,10,50,100,200),b=c(0.1,0.5,1,1.1,1.5),z=c(0.1,1,10))
start<-list(a=NA,b=NA,c=round(max(repObs$logabund),1),z=NA)
#start<-list(a=NA, b=NA, z=NA)
grid.starts<-as.matrix(expand.grid(grids))
ncombos<-dim(grid.starts)[[1]]
# cycle through each combo
res.mat<-matrix(NA,nrow=ncombos,ncol=I(length(start)+1))
res.mod<-list()
for(k in 1:dim(grid.starts)[[1]]){
#some how need to match grid parameters to start lists.
mod.start<-as.list(grid.starts[k,])
new.start<-start
new.start[names(start) %in% names(mod.start)]<-mod.start
pscale<-as.numeric(new.start)
names(pscale)<-names(new.start)
#fit <- mle2(minuslogl=logabund ~ dnorm(mean = c * (time / a)^(b-1) * exp(-1*(time/a)^b), sd = z),
#                        start = new.start, data = repObs,
#                        control=list(parscale=pscale, maxit=1000),
#                        method="Nelder-Mead", hessian = T)
fit <- mle2(minuslogl=prop ~ dnorm(mean = exp( -1 * ((time / a)^ b)), sd = z),
start = new.start, data = repObs,
control=list(parscale=pscale, maxit=1000),
method="Nelder-Mead", hessian = T)
res.mat[k,]<-c(coef(fit),AIC(fit))
res.mod[[k]]<-fit
}
colnames(res.mat)<-c(names(coef(fit)),"AIC")
best.fit<-res.mod[[which(res.mat[,'AIC']==min(res.mat[,'AIC']))[1]]]
summ[counter,1]=strains[i]
summ[counter,2]=reps[j]
#CIs <- confint( profile(best.fit))
print(coef(best.fit))
# a
summ[counter,3]=coef(best.fit)[1]
# b
summ[counter,4]=coef(best.fit)[2]
# c
summ[counter,5]=coef(best.fit)[3]
#summ[counter,5]= round(max(repObs$logabund),1)
# z
summ[counter,6]=coef(best.fit)[4]
summ[counter,7]=AIC(best.fit)
#summ[counter,8]=CIs[1,1]
#summ[counter,9]=CIs[1,2]
#summ[counter,10]=CIs[2,1]
#summ[counter,11]=CIs[2,2]
#summ[counter,12]=CIs[3,1]
#summ[counter,13]=CIs[3,2]
#summ[counter,14]=CIs[4,1]
#summ[counter,15]=CIs[4,2]
summ[counter,8]=length(repObs$time)
### *** Comment/Uncomment following code to make pdf figs*** ###
title=paste(strains[i],"  rep ",reps[j])
plot(repObs$time,repObs$prop,main=title,ylim=c(0,1))
predTime=seq(0,max(repObs$time))
print(strains[i])
print(reps[j])
#exp( -1 * ((time / a)^ b))
#coef(best.fit)[3]
lines(repObs$time, exp( -1 * ((repObs$time / coef(best.fit)[1] )^ coef(best.fit)[2])),
lwd=4, lty=2, col = "red")
counter=counter+1
}
}
}
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/")
library('bbmle')
## Load Data
obs <- read.csv("data/longtermdormancy_20170620_nocomments.csv",
header = TRUE, stringsAsFactors = FALSE)
## Adding 1 to deal with log(0) observations
obs$Abund <- as.numeric(obs$Colonies) * 10 ^ as.numeric(obs$Dilution) + 1
strains <- sort(unique(obs$Strain))
strains <- strains[table(obs$Strain)>10]
obs <- obs[obs$Strain%in%strains,]
summ <- matrix(NA,length(strains)*max(obs$Rep),8)
pdf('output/decayFitsWeibull.pdf') # Uncomment to create pdf that will plot data and fits
counter <- 1
for(i in 1:length(strains)){
strainObs=obs[obs$Strain==strains[i],]
reps=unique(strainObs$Rep)
for(j in 1:length(reps)){
repObs=strainObs[strainObs$Rep==reps[j],]
# minimum of 10 data points
if(nrow(repObs)>10){
start=repObs[1,1]
time=(as.numeric(strptime(repObs$Firstread_date,format="%d-%b-%y",tz="EST"))-
as.numeric(strptime(start,format="%d-%b-%y",tz="EST")))/(3600*24)
repObs["time"] <- time + 1
repObs["logabund"] <- log10(repObs$Abund)
if (repObs["logabund"][[1]][2] - repObs["logabund"][[1]][1] > 1){
repObs <- repObs[-c(1), ]
}
repObs["prop"] <- repObs$logabund / repObs$logabund[1]
#KBS0703.1$prop <- KBS0703.1$logabund/KBS0703.1$logabund[1]
# Initial parameters
#A = 200 # Initial death (larger = slower)
#B = 1 # Bend (upper = 1 = first-order decay)
#C = round(max(repObs$logabund),1) # intercept
#Z = 6 # Error
grids<-list(a=c(1,10,50,100,200),b=c(0.1,0.5,1,1.1,1.5),z=c(0.1,1,10))
#start<-list(a=NA,b=NA,c=round(max(repObs$logabund),1),z=NA)
start<-list(a=NA,b=NA,z=NA)
grid.starts<-as.matrix(expand.grid(grids))
ncombos<-dim(grid.starts)[[1]]
# cycle through each combo
res.mat<-matrix(NA,nrow=ncombos,ncol=I(length(start)+1))
res.mod<-list()
for(k in 1:dim(grid.starts)[[1]]){
#some how need to match grid parameters to start lists.
mod.start<-as.list(grid.starts[k,])
new.start<-start
new.start[names(start) %in% names(mod.start)]<-mod.start
pscale<-as.numeric(new.start)
names(pscale)<-names(new.start)
#fit <- mle2(minuslogl=logabund ~ dnorm(mean = c * (time / a)^(b-1) * exp(-1*(time/a)^b), sd = z),
#                        start = new.start, data = repObs,
#                        control=list(parscale=pscale, maxit=1000),
#                        method="Nelder-Mead", hessian = T)
fit <- mle2(minuslogl=prop ~ dnorm(mean = exp( -1 * ((time / a)^ b)), sd = z),
start = new.start, data = repObs,
control=list(parscale=pscale, maxit=1000),
method="Nelder-Mead", hessian = T)
res.mat[k,]<-c(coef(fit),AIC(fit))
res.mod[[k]]<-fit
}
colnames(res.mat)<-c(names(coef(fit)),"AIC")
best.fit<-res.mod[[which(res.mat[,'AIC']==min(res.mat[,'AIC']))[1]]]
summ[counter,1]=strains[i]
summ[counter,2]=reps[j]
#CIs <- confint( profile(best.fit))
print(coef(best.fit))
# a
summ[counter,3]=coef(best.fit)[1]
# b
summ[counter,4]=coef(best.fit)[2]
# c
summ[counter,5]=coef(best.fit)[3]
#summ[counter,5]= round(max(repObs$logabund),1)
# z
summ[counter,6]=coef(best.fit)[4]
summ[counter,7]=AIC(best.fit)
#summ[counter,8]=CIs[1,1]
#summ[counter,9]=CIs[1,2]
#summ[counter,10]=CIs[2,1]
#summ[counter,11]=CIs[2,2]
#summ[counter,12]=CIs[3,1]
#summ[counter,13]=CIs[3,2]
#summ[counter,14]=CIs[4,1]
#summ[counter,15]=CIs[4,2]
summ[counter,8]=length(repObs$time)
### *** Comment/Uncomment following code to make pdf figs*** ###
title=paste(strains[i],"  rep ",reps[j])
plot(repObs$time,repObs$prop,main=title,ylim=c(0,1))
predTime=seq(0,max(repObs$time))
print(strains[i])
print(reps[j])
#exp( -1 * ((time / a)^ b))
#coef(best.fit)[3]
lines(repObs$time, exp( -1 * ((repObs$time / coef(best.fit)[1] )^ coef(best.fit)[2])),
lwd=4, lty=2, col = "red")
counter=counter+1
}
}
}
dev.off()
summ=summ[!is.na(summ[,1]),]
#colnames(summ)=c('strain','rep','a','b','c','z','AIC', 'a.CI.2.5', 'a.CI.97.5', 'b.CI.2.5', 'b.CI.97.5', 'c.CI.2.5', 'c.CI.97.5', 'z.CI.2.5', 'z.CI.97.5')
colnames(summ)=c('strain','rep','a','b','c','z','AIC', 'N.obs')
write.csv(summ,"data/weibull_results.csv")
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/")
library('bbmle')
## Load Data
obs <- read.csv("data/longtermdormancy_20170620_nocomments.csv",
header = TRUE, stringsAsFactors = FALSE)
## Adding 1 to deal with log(0) observations
obs$Abund <- as.numeric(obs$Colonies) * 10 ^ as.numeric(obs$Dilution) + 1
strains <- sort(unique(obs$Strain))
strains <- strains[table(obs$Strain)>10]
obs <- obs[obs$Strain%in%strains,]
summ <- matrix(NA,length(strains)*max(obs$Rep),8)
pdf('output/decayFitsWeibull.pdf') # Uncomment to create pdf that will plot data and fits
counter <- 1
for(i in 1:length(strains)){
strainObs=obs[obs$Strain==strains[i],]
reps=unique(strainObs$Rep)
for(j in 1:length(reps)){
repObs=strainObs[strainObs$Rep==reps[j],]
# minimum of 10 data points
if(nrow(repObs)>10){
start=repObs[1,1]
time=(as.numeric(strptime(repObs$Firstread_date,format="%d-%b-%y",tz="EST"))-
as.numeric(strptime(start,format="%d-%b-%y",tz="EST")))/(3600*24)
repObs["time"] <- time + 1
repObs["logabund"] <- log10(repObs$Abund)
if (repObs["logabund"][[1]][2] - repObs["logabund"][[1]][1] > 1){
repObs <- repObs[-c(1), ]
}
repObs["prop"] <- repObs$logabund / repObs$logabund[1]
#KBS0703.1$prop <- KBS0703.1$logabund/KBS0703.1$logabund[1]
# Initial parameters
#A = 200 # Initial death (larger = slower)
#B = 1 # Bend (upper = 1 = first-order decay)
#C = round(max(repObs$logabund),1) # intercept
#Z = 6 # Error
grids<-list(a=c(1,10,50,100,200),b=c(0.1,0.5,1,1.1,1.5),z=c(0.1,1,10))
#start<-list(a=NA,b=NA,c=round(max(repObs$logabund),1),z=NA)
start<-list(a=NA,b=NA,z=NA)
grid.starts<-as.matrix(expand.grid(grids))
ncombos<-dim(grid.starts)[[1]]
# cycle through each combo
res.mat<-matrix(NA,nrow=ncombos,ncol=I(length(start)+1))
res.mod<-list()
for(k in 1:dim(grid.starts)[[1]]){
#some how need to match grid parameters to start lists.
mod.start<-as.list(grid.starts[k,])
new.start<-start
new.start[names(start) %in% names(mod.start)]<-mod.start
pscale<-as.numeric(new.start)
names(pscale)<-names(new.start)
#fit <- mle2(minuslogl=logabund ~ dnorm(mean = c * (time / a)^(b-1) * exp(-1*(time/a)^b), sd = z),
#                        start = new.start, data = repObs,
#                        control=list(parscale=pscale, maxit=1000),
#                        method="Nelder-Mead", hessian = T)
fit <- mle2(minuslogl=prop ~ dnorm(mean = exp( -1 * ((time / a)^ b)), sd = z),
start = new.start, data = repObs,
control=list(parscale=pscale, maxit=1000),
method="Nelder-Mead", hessian = T)
res.mat[k,]<-c(coef(fit),AIC(fit))
res.mod[[k]]<-fit
}
colnames(res.mat)<-c(names(coef(fit)),"AIC")
best.fit<-res.mod[[which(res.mat[,'AIC']==min(res.mat[,'AIC']))[1]]]
summ[counter,1]=strains[i]
summ[counter,2]=reps[j]
#CIs <- confint( profile(best.fit))
print(coef(best.fit))
# a
summ[counter,3]=coef(best.fit)[1]
# b
summ[counter,4]=coef(best.fit)[2]
# c
summ[counter,5]=coef(best.fit)[3]
#summ[counter,5]= round(max(repObs$logabund),1)
# z
summ[counter,6]=coef(best.fit)[4]
summ[counter,7]=AIC(best.fit)
#summ[counter,8]=CIs[1,1]
#summ[counter,9]=CIs[1,2]
#summ[counter,10]=CIs[2,1]
#summ[counter,11]=CIs[2,2]
#summ[counter,12]=CIs[3,1]
#summ[counter,13]=CIs[3,2]
#summ[counter,14]=CIs[4,1]
#summ[counter,15]=CIs[4,2]
summ[counter,8]=length(repObs$time)
### *** Comment/Uncomment following code to make pdf figs*** ###
title=paste(strains[i],"  rep ",reps[j])
plot(repObs$time,repObs$prop,main=title,ylim=c(0,1))
predTime=seq(0,max(repObs$time))
print(strains[i])
print(reps[j])
#exp( -1 * ((time / a)^ b))
#coef(best.fit)[3]
lines(repObs$time, exp( -1 * ((repObs$time / coef(best.fit)[1] )^ coef(best.fit)[2])),
lwd=4, lty=2, col = "red")
counter=counter+1
}
}
}
dev.off()
summ=summ[!is.na(summ[,1]),]
#colnames(summ)=c('strain','rep','a','b','c','z','AIC', 'a.CI.2.5', 'a.CI.97.5', 'b.CI.2.5', 'b.CI.97.5', 'c.CI.2.5', 'c.CI.97.5', 'z.CI.2.5', 'z.CI.97.5')
colnames(summ)=c('strain','rep','a','b','z','AIC', 'N.obs')
write.csv(summ,"data/weibull_results.csv")
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/phylo")
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/")
library('bbmle')
## Load Data
obs <- read.csv("data/longtermdormancy_20170620_nocomments.csv",
header = TRUE, stringsAsFactors = FALSE)
## Adding 1 to deal with log(0) observations
obs$Abund <- as.numeric(obs$Colonies) * 10 ^ as.numeric(obs$Dilution) + 1
strains <- sort(unique(obs$Strain))
strains <- strains[table(obs$Strain)>10]
obs <- obs[obs$Strain%in%strains,]
summ <- matrix(NA,length(strains)*max(obs$Rep),7)
pdf('output/decayFitsWeibull.pdf') # Uncomment to create pdf that will plot data and fits
counter <- 1
for(i in 1:length(strains)){
strainObs=obs[obs$Strain==strains[i],]
reps=unique(strainObs$Rep)
for(j in 1:length(reps)){
repObs=strainObs[strainObs$Rep==reps[j],]
# minimum of 10 data points
if(nrow(repObs)>10){
start=repObs[1,1]
time=(as.numeric(strptime(repObs$Firstread_date,format="%d-%b-%y",tz="EST"))-
as.numeric(strptime(start,format="%d-%b-%y",tz="EST")))/(3600*24)
repObs["time"] <- time + 1
repObs["logabund"] <- log10(repObs$Abund)
if (repObs["logabund"][[1]][2] - repObs["logabund"][[1]][1] > 1){
repObs <- repObs[-c(1), ]
}
repObs["prop"] <- repObs$logabund / repObs$logabund[1]
#KBS0703.1$prop <- KBS0703.1$logabund/KBS0703.1$logabund[1]
# Initial parameters
#A = 200 # Initial death (larger = slower)
#B = 1 # Bend (upper = 1 = first-order decay)
#C = round(max(repObs$logabund),1) # intercept
#Z = 6 # Error
grids<-list(a=c(1,10,50,100,200),b=c(0.1,0.5,1,1.1,1.5),z=c(0.1,1,10))
#start<-list(a=NA,b=NA,c=round(max(repObs$logabund),1),z=NA)
start<-list(a=NA,b=NA,z=NA)
grid.starts<-as.matrix(expand.grid(grids))
ncombos<-dim(grid.starts)[[1]]
# cycle through each combo
res.mat<-matrix(NA,nrow=ncombos,ncol=I(length(start)+1))
res.mod<-list()
for(k in 1:dim(grid.starts)[[1]]){
#some how need to match grid parameters to start lists.
mod.start<-as.list(grid.starts[k,])
new.start<-start
new.start[names(start) %in% names(mod.start)]<-mod.start
pscale<-as.numeric(new.start)
names(pscale)<-names(new.start)
#fit <- mle2(minuslogl=logabund ~ dnorm(mean = c * (time / a)^(b-1) * exp(-1*(time/a)^b), sd = z),
#                        start = new.start, data = repObs,
#                        control=list(parscale=pscale, maxit=1000),
#                        method="Nelder-Mead", hessian = T)
fit <- mle2(minuslogl=prop ~ dnorm(mean = exp( -1 * ((time / a)^ b)), sd = z),
start = new.start, data = repObs,
control=list(parscale=pscale, maxit=1000),
method="Nelder-Mead", hessian = T)
res.mat[k,]<-c(coef(fit),AIC(fit))
res.mod[[k]]<-fit
}
colnames(res.mat)<-c(names(coef(fit)),"AIC")
best.fit<-res.mod[[which(res.mat[,'AIC']==min(res.mat[,'AIC']))[1]]]
summ[counter,1]=strains[i]
summ[counter,2]=reps[j]
#CIs <- confint( profile(best.fit))
print(coef(best.fit))
# a
summ[counter,3]=coef(best.fit)[1]
# b
summ[counter,4]=coef(best.fit)[2]
# c
summ[counter,5]=coef(best.fit)[3]
#summ[counter,5]= round(max(repObs$logabund),1)
# z
summ[counter,6]=AIC(best.fit)
#summ[counter,8]=CIs[1,1]
#summ[counter,9]=CIs[1,2]
#summ[counter,10]=CIs[2,1]
#summ[counter,11]=CIs[2,2]
#summ[counter,12]=CIs[3,1]
#summ[counter,13]=CIs[3,2]
#summ[counter,14]=CIs[4,1]
#summ[counter,15]=CIs[4,2]
summ[counter,7]=length(repObs$time)
### *** Comment/Uncomment following code to make pdf figs*** ###
title=paste(strains[i],"  rep ",reps[j])
plot(repObs$time,repObs$prop,main=title,ylim=c(0,1))
predTime=seq(0,max(repObs$time))
print(strains[i])
print(reps[j])
#exp( -1 * ((time / a)^ b))
#coef(best.fit)[3]
lines(repObs$time, exp( -1 * ((repObs$time / coef(best.fit)[1] )^ coef(best.fit)[2])),
lwd=4, lty=2, col = "red")
counter=counter+1
}
}
}
dev.off()
summ=summ[!is.na(summ[,1]),]
#colnames(summ)=c('strain','rep','a','b','c','z','AIC', 'a.CI.2.5', 'a.CI.97.5', 'b.CI.2.5', 'b.CI.97.5', 'c.CI.2.5', 'c.CI.97.5', 'z.CI.2.5', 'z.CI.97.5')
colnames(summ)=c('strain','rep','a','b','z','AIC', 'N.obs')
write.csv(summ,"data/weibull_results.csv")
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/phylo")
package.list <- c('ape', 'seqinr', 'phylobase', 'adephylo', 'geiger', 'picante', 'stats', 'RColorBrewer', 'caper', 'phylolm', 'pmc', 'ggplot2', 'tidyr', 'dplyr', 'phangorn', 'pander', 'phytools')
for (package in package.list) {
if (!require(package, character.only=TRUE, quietly=TRUE)) {
install.packages(package)
library(package, character.only=TRUE)
}
}
rm(list = ls())
getwd()
setwd("~/GitHub/Dimensions/Aim1/DeathCurves/Phylo")
require("muscle")
require("seqinr")
require("ape")
require("phylobase")
require("adephylo")
require("geiger")
require("picante")
require("stats")
require("RColorBrewer")
require("caper")
fasta <- read.fasta(file = "./persistence.fasta", seqtype = "DNA")
summary(fasta)
read.aln.M <- read.alignment(file = "./persistence.good.filter.silva.afa", format = "fasta")
p.DNAbin.M <- as.DNAbin(read.aln.M)
window.M <- p.DNAbin.M[, 1:320]
image.DNAbin(window.M, cex.lab = 0.50)
image.DNAbin(window.M, cex.lab = 0.50)
p.DNAbin.M
image.DNAbin(window.M, cex.lab = 0.50)
read.aln.M <- read.alignment(file = "./persistence.good.filter.silva.afa", format = "fasta")
read.aln.M
p.DNAbin.M <- as.DNAbin(read.aln.M)
p.DNAbin.M
read.aln.M <- read.alignment(file = "./persistence.good.filter.silva.afa", format = "fasta")
p.DNAbin.M <- as.DNAbin(read.aln.M)
p.DNAbin.M
